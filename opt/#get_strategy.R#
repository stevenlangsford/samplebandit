library(tidyverse)
source("goldenline.R")#contains rm(list=ls())
##goldenline.R puts seen_states and opt_only in the environment.
##Both hash tables with infostate strings as keys
##seen states values are lists, info about current features and children.
##opt_only values are action strings.
##action strings start with choose, p[rob], or v[alue], followed by features.
##There might be more than one action, separated by OR.


##setup
populate_optonly(init$mystringid, 3)

whichstep <- 3 #step 1 is init, so last step is hm_obs_available + 1

##end setup. populate action-group and description-group, then find matches.
thisstep <- opt_only[names(opt_only)[sapply(names(opt_only),
       function(x){
           str_count(x, "NA") == 7 - whichstep #ugh magic number (features+1)
       })]
       ]

actiongroup <- list()
for (astate in names(thisstep)){
    anaction <- thisstep[[astate]]
    if (is.null(actiongroup[[anaction]])){
        actiongroup[[anaction]] <- astate
    }else{
        actiongroup[[anaction]] <- c(actiongroup[[anaction]], astate)
    }
}

##Ge the groups that match easy descriptions. Then see if they match an action
descriptiongroup <- list()

##containsX
for (astate in names(seen_states)){
    for (alevel in c(prob_levels, payoff_levels, "NA")){
        if (str_count(astate, alevel) > 0){
            if (is.null(descriptiongroup[[paste0("contains_", alevel)]])){
                descriptiongroup[[paste0("contains_", alevel)]] <-
                    list()
            }else{
                descriptiongroup[[paste0("contains_", alevel)]] <-
                    c(descriptiongroup[[paste0("contains_", alevel)]], astate)
                }
        }
    }
}
##highest_is_X


## ##helpers
## all_possible_options <- c()
## for (problevel in c(prob_levels, "NA")){
##     for (paylevel in c(payoff_levels, "NA")){
##         all_possible_options <- c(all_possible_options,
##                                   paste(problevel, paylevel)
##                                   )
##     }
## }

## best_description <- function(actionlist){
##     singleoptionfacts <- list()
    
##     for(i in 1:length(actionlist)){
##         myaction <- names(actionlist[i])
##         somestates <- actionlist[[i]]

    
##     ##All contain a specific pair of features
##     optiontype_counter <- hash()
##     for (anoption in all_possible_options){
##         optiontype_counter[[anoption]] <- 0
##     }
##     for (astate in somestates){
##         stateinfo <- seen_states[[astate]]
##         myoptions <- c(paste(stateinfo$myfeatures$p1,
##                              stateinfo$myfeatures$v1),
##                        paste(stateinfo$myfeatures$p2,
##                              stateinfo$myfeatures$v2),
##                        paste(stateinfo$myfeatures$p3,
##                              stateinfo$myfeatures$v3)
##                        )
##         for (anoption in all_possible_options){
##             if (anoption %in% myoptions){
##                 optiontype_counter[[anoption]] <-
##                     optiontype_counter[[anoption]] + 1
##             }
##         }
##     }

    
    
##     for (acount in names(optiontype_counter)){
##         optiontype_counter[[acount]] <-
##                     optiontype_counter[[acount]] / length(somestates)
            
##     }

##         singleoptionfacts[[i]] <- optiontype_counter
##     ##All equal on something?
##     ##All below threshold on something?
##     ##Check your favorite feature is not true of the outgroup.
##     ##If there isn't one, report the list.
##     }#for each group in actionlist
    
##     names(singleoptionfacts) <- names(actionlist)
##     browser()
##     print("browser")
## }

## ##MAIN
## best_description(actiongroup)
